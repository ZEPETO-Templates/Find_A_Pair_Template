fileFormatVersion: 2
guid: 973fbf2751fb4654cb5d2f8acdb422a6
importerOverride: ZEPETO.Script.Compiler:ZEPETO.Script:TypescriptAssetImporter
ScriptedImporter:
  internalIDToNameTable: []
  externalObjects: {}
  serializedVersion: 2
  userData: 
  assetBundleName: 
  assetBundleVariant: 
  script: {fileID: -1123457745, guid: 54cf806323ffe4418a4ce4cc63fe6b9d, type: 3}
  isAssemblyDeclarations: 0
  assembly: 
  generateAllTypes: 1
  types: []
  generateWrapper: 0
  overrideWrapperTypes: 0
  wrapperTypes: []
  WrapperFilters: []
  wrapperOutputDirectory: Generated
  compiledResult: '{"source":"\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\",
    { value: true });\r\nconst UnityEngine_1 = require(\"UnityEngine\");\r\nconst
    ZEPETO_Script_1 = require(\"ZEPETO.Script\");\r\nconst System_Collections_Generic_1
    = require(\"System.Collections.Generic\");\r\nconst UICard_1 = require(\"../UICard\");\r\nconst
    UIManager_1 = require(\"./UIManager\");\r\n// This class is responsible for handling
    everything related to the gameplay of the game, calling other managers if necessary\r\nclass
    GameManager extends ZEPETO_Script_1.ZepetoScriptBehaviour {\r\n    constructor()
    {\r\n        super(...arguments);\r\n        this.pairsFounded = 0; // This variable
    saves the amount of pairs that have found the player\r\n        this.cards =
    new Map(); // This variables saves the created cards for the use on the game
    matrix\r\n    }\r\n    // This function set the pairAmount variable and create
    a new matrix\r\n    SetPairAmount(amount) {\r\n        // Set the pair amount
    on his variable\r\n        this.pairAmount = amount;\r\n        // Call to the
    function to destroy the actual matrix\r\n        this.MatrixDestruction();\r\n       
    // Call to the function to create a new matrix\r\n        this.MatrixCreation();\r\n   
    }\r\n    // This function return the pair amount number variable\r\n    GetPairAmount()
    {\r\n        return this.pairAmount;\r\n    }\r\n    // Awake is called when
    an enabled script instance is being loaded.\r\n    Awake() {\r\n        // Singleton
    pattern\r\n        if (ZEPETO_Script_1.ZepetoScriptBehaviour.op_Inequality(GameManager.instance,
    null))\r\n            UnityEngine_1.GameObject.Destroy(this.gameObject);\r\n       
    else\r\n            GameManager.instance = this;\r\n        // Array initialization\r\n       
    this.selections = [];\r\n        this.rows = [];\r\n    }\r\n    // Start is
    called on the frame when a script is enabled just before any of the Update methods
    are called the first time\r\n    Start() {\r\n        // Call to the function
    to create the base cards that can be created on a game\r\n        this.CardsCreation();\r\n       
    // Call to the function to create a new matrix\r\n        this.MatrixCreation();\r\n   
    }\r\n    // This function create a card for each sprite saved on the variable
    \"sprites\"\r\n    CardsCreation() {\r\n        // First we create a counter\r\n       
    let counter = 0;\r\n        // Then foreach sprite\r\n        this.sprites.forEach(sprite
    => {\r\n            // Set a new card on the \"cards\" map with the counter as
    ID and the sprite\r\n            this.cards.set(counter, sprite);\r\n           
    // increase te counter\r\n            counter++;\r\n        });\r\n    }\r\n   
    // This function resets the matrix, setting the variable \"founded\" for the
    cards to false and calling the \"ShuffleMatrix\" function\r\n    ResetMatrix()
    {\r\n        // First get all the UICards that are children of the tableParent\r\n       
    const cards = this.tableParent.GetComponentsInChildren($typeof(UICard_1.default),
    true);\r\n        // Then foreach card\r\n        cards.forEach(card => {\r\n           
    // Call the function SetFoundedCard and send false to reset the card\r\n           
    card.SetFoundedCard(false);\r\n        });\r\n        // Call to the function
    ShuffleMatrix\r\n        this.ShuffleMatrix();\r\n        // And reset the variables
    of the game to 0\r\n        this.pairsFounded = 0;\r\n        this.tries = 0;\r\n   
    }\r\n    // This function destroys the matrix\r\n    MatrixDestruction() {\r\n       
    // For each row on the rows array, destroy the row\r\n        for (let i = 0;
    i < this.rows.length; i++)\r\n            UnityEngine_1.GameObject.Destroy(this.rows[i]);\r\n   
    }\r\n    // This function create the matrix for the game\r\n    MatrixCreation()
    {\r\n        // First limit the pair amount getting the limit from the LimitPairAmount
    function\r\n        this.pairAmount = this.LimitPairAmount(this.pairAmount);\r\n       
    // Then set a widht of every row getting the value from the function DeterminateWidth
    \r\n        let width = this.DeterminateWidth();\r\n        // Let a variable
    to save the amount of cards to create this game\r\n        let cardsToCreate
    = this.pairAmount * 2;\r\n        // Create the first row getting it from the
    CreateRow function\r\n        let row = this.CreateRow();\r\n        // Set a
    variable to know who is the row parent\r\n        let rowParent = row.transform;\r\n       
    // Create a x variable to know in wich place will stay the new card\r\n       
    let x = 0;\r\n        // And set a cardId to start\r\n        let cardId = 0;\r\n       
    // While we have cards to create\r\n        while (cardsToCreate > 0) {\r\n           
    // Check if x is equal to width and if there is no more cards to create\r\n           
    if (x == width && cardsToCreate > 0) {\r\n                // Create a new row\r\n               
    row = this.CreateRow();\r\n                // And set the new parent\r\n               
    rowParent = row.transform;\r\n                // Reset the x to 0\r\n               
    x = 0;\r\n            }\r\n            // if not\r\n            // create a new
    card instantiating a card prefab on the rowParent and saving it into a variable\r\n           
    let newCard = UnityEngine_1.GameObject.Instantiate(this.cardPrefab, rowParent);\r\n           
    // Then save the card script(UICard) into a variable\r\n            let newCardScript
    = newCard.GetComponent($typeof(UICard_1.default));\r\n            // Check if
    the number of cards is even, and if it''s not the first card, then add 1 to the
    variable \"cardId\"\r\n            if ((cardsToCreate % 2) == 0 && cardsToCreate
    != this.pairAmount * 2)\r\n                cardId++;\r\n            // Check
    if the cardId if greater or equal to the cards map lenght and set it to 0 to
    create again from 0\r\n            if (cardId >= this.cards.size)\r\n               
    cardId = 0;\r\n            // Then save the id on the UICard script saved\r\n           
    newCardScript.id = cardId;\r\n            // Then save the showingSprite of the
    script getting it from the cards map by the id\r\n            newCardScript.showingSprite
    = this.cards.get(cardId);\r\n            // Rest 1 to cards to create\r\n           
    cardsToCreate--;\r\n            // Add 1 to x\r\n            x++;\r\n       
    }\r\n        // When the cards are created update the pairs founded to the new
    amount\r\n        // Call to the UpdatePairsFounded on UIManager\r\n        UIManager_1.default.instance.UpdatePairsFounded(this.pairsFounded,
    this.pairAmount);\r\n        // Then Suffle the matrix to start the game\r\n       
    this.ShuffleMatrix();\r\n    }\r\n    // This function shuffles the matrix to
    randomize the pairs\r\n    ShuffleMatrix() {\r\n        // Get the cards from
    the tableparent childs\r\n        const cards = this.tableParent.GetComponentsInChildren($typeof(UICard_1.default),
    true);\r\n        // Set the card count on the cards obtained lenght\r\n       
    const cardCount = cards.length;\r\n        // Get a list of index for the cards\r\n       
    const index = new ($generic(System_Collections_Generic_1.List$1, $typeof(\"System.Double\")))();\r\n       
    for (let i = 0; i < cardCount; i++) {\r\n            index.Add(i);\r\n       
    }\r\n        // Randomly shuffle the indices.\r\n        for (let i = 0; i <
    cardCount; i++) {\r\n            // Create a randomIndex between 0 and the index
    count\r\n            const randomIndex = UnityEngine_1.Random.Range(0, index.Count);\r\n           
    // Create a current indes with the actual index\r\n            const currentIndex
    = index.get_Item(i);\r\n            // Create a random swap with them\r\n           
    const randomSwapIndex = index.get_Item(randomIndex);\r\n            // Swap the
    sprites and IDs between the cards\r\n            // Create a temporal sprite
    with the sprite of the card with the current index\r\n            const tempSprite
    = cards[currentIndex].showingSprite;\r\n            // Create a temporal id with
    the card of the current index     \r\n            const tempId = cards[currentIndex].id;\r\n           
    // Then swap the cards\r\n            // The card with the current index gets
    the card with the randomSwapIndex\r\n            cards[currentIndex].showingSprite
    = cards[randomSwapIndex].showingSprite;\r\n            cards[currentIndex].id
    = cards[randomSwapIndex].id;\r\n            // And the card with the random swap
    gets the temporal variables that we create before\r\n            cards[randomSwapIndex].showingSprite
    = tempSprite;\r\n            cards[randomSwapIndex].id = tempId;\r\n        }\r\n   
    }\r\n    // This function creates a row in the table parent with the row prefab\r\n   
    CreateRow() {\r\n        // create a object to save the instantiated prefab of
    the row in the table parent\r\n        let obj = UnityEngine_1.GameObject.Instantiate(this.rowPrefab,
    this.tableParent);\r\n        // Save the object on the rows array\r\n       
    this.rows.push(obj);\r\n        return obj;\r\n    }\r\n    // This function
    returns the number of the limit of pairs to create to dont broke the game\r\n   
    LimitPairAmount(limit) {\r\n        // If the limit (parameter) is less or equal
    to 1 the set the limit in 2\r\n        if (limit <= 1)\r\n            limit =
    2;\r\n        // If the limit (parameter) is greater than 16 the set the limit
    in 16\r\n        if (limit > 16)\r\n            limit = 16;\r\n        return
    limit;\r\n    }\r\n    // This function determines the \"width\" based on the
    number of pairs to display\r\n    DeterminateWidth() {\r\n        // First create
    the width on 0\r\n        let width = 0;\r\n        // If the pair amount is
    less than 6 then the width is equal to pair amount\r\n        if (this.pairAmount
    < 6)\r\n            width = this.pairAmount;\r\n        // If the pair amount
    is greater or equal to 6 then the width is equal to pair amount / 2\r\n       
    if (this.pairAmount >= 6)\r\n            width = this.pairAmount / 2;\r\n       
    // If the pair amount is greater than 12 then the width is equal to 8\r\n       
    if (this.pairAmount > 12)\r\n            width = 8;\r\n        // Then round
    it to int to avoid float numbers\r\n        width = UnityEngine_1.Mathf.RoundToInt(width);\r\n       
    return width;\r\n    }\r\n    // This function get a card to select and push
    it into the selections and if the selections are 2 then compare them\r\n    SelectCard(card)
    {\r\n        // Push the card passed by parameter into the selections array\r\n       
    this.selections.push(card);\r\n        // Check if the selections are already
    2 then start the corountine to compare them\r\n        if (this.selections.length
    >= 2)\r\n            this.StartCoroutine(this.CompareSelections());\r\n    }\r\n   
    // This corountine compare both of the selections and work in based of that\r\n   
    *CompareSelections() {\r\n        // increase the amount of tries\r\n       
    this.tries++;\r\n        // Show the blocker calling to the ShowBlocker function
    in the UIManager\r\n        UIManager_1.default.instance.ShowBlocker(true);\r\n       
    // Check if the selections have the same id\r\n        if (this.selections[0].id
    == this.selections[1].id) {\r\n            // Set both cards selected to founded
    calling at their SetFoundedCard function\r\n            this.selections[0].SetFoundedCard(true);\r\n           
    this.selections[1].SetFoundedCard(true);\r\n            // Increase the amount
    of pairs founded\r\n            this.pairsFounded++;\r\n            // Call to
    the UpdatePairsFounded in the UIManager\r\n            UIManager_1.default.instance.UpdatePairsFounded(this.pairsFounded,
    this.pairAmount);\r\n            // Wait 1 second\r\n            yield new UnityEngine_1.WaitForSeconds(1);\r\n           
    // Clean the selections array\r\n            for (let i = 0; i <= this.selections.length;
    i++)\r\n                this.selections.pop();\r\n            // Then start the
    coroutine to check if the player won\r\n            this.StartCoroutine(this.CheckForWin());\r\n       
    }\r\n        else {\r\n            // Wait 1 second\r\n            yield new
    UnityEngine_1.WaitForSeconds(1);\r\n            // The hide the cards calling
    to the function ShowCard on false\r\n            this.selections[0].ShowCard(false);\r\n           
    this.selections[1].ShowCard(false);\r\n            // Clean the selections array\r\n           
    for (let i = 0; i <= this.selections.length; i++)\r\n                this.selections.pop();\r\n           
    // Call to fhe function ShowBlocker in the UIManager\r\n            UIManager_1.default.instance.ShowBlocker(false);\r\n       
    }\r\n    }\r\n    // This function checks if the player has founded all the cards\r\n   
    *CheckForWin() {\r\n        // Check if the pairs founced are equal to the pairs
    amount\r\n        if (this.pairsFounded == this.pairAmount) {\r\n           
    // Wait 0.3 seconds\r\n            yield new UnityEngine_1.WaitForSeconds(0.3);\r\n           
    // Call to fhe function to show the end panel in the UIManager\r\n           
    UIManager_1.default.instance.ShowPanel(UIManager_1.UIPanel.End);\r\n           
    // Call to the function to reset the matrix\r\n            this.ResetMatrix();\r\n       
    }\r\n        // Call to fhe function ShowBlocker in the UIManager\r\n       
    UIManager_1.default.instance.ShowBlocker(false);\r\n    }\r\n}\r\nexports.default
    = GameManager;\r\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR2FtZU1hbmFnZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyJHYW1lTWFuYWdlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZDQUEyRjtBQUMzRixpREFBcUQ7QUFDckQsMkVBQW9EO0FBQ3BELHNDQUErQjtBQUMvQiwyQ0FBaUQ7QUFFakQsNkhBQTZIO0FBQzdILE1BQXFCLFdBQVksU0FBUSxxQ0FBcUI7SUFBOUQ7O1FBZ0JZLGlCQUFZLEdBQVcsQ0FBQyxDQUFDLENBQUMscUVBQXFFO1FBRy9GLFVBQUssR0FBd0IsSUFBSSxHQUFHLEVBQWtCLENBQUMsQ0FBQyx3RUFBd0U7SUE2UjVJLENBQUM7SUExUkcsb0VBQW9FO0lBQ3BFLGFBQWEsQ0FBRyxNQUFjO1FBQzFCLHNDQUFzQztRQUN0QyxJQUFJLENBQUMsVUFBVSxHQUFHLE1BQU0sQ0FBQztRQUN6QixvREFBb0Q7UUFDcEQsSUFBSSxDQUFDLGlCQUFpQixFQUFFLENBQUM7UUFDekIsOENBQThDO1FBQzlDLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQsdURBQXVEO0lBQ3ZELGFBQWE7UUFDVCxPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDM0IsQ0FBQztJQUVELG1FQUFtRTtJQUNuRSxLQUFLO1FBQ0Qsb0JBQW9CO1FBQ3BCLElBOUNDLHFDQUFxQixDQWdLdEIsYUFBSyxDQWxIQSxXQUFXLENBQUMsUUFBUSxFQUFJLElBQUk7WUFBRyx3QkFBVSxDQUFDLE9BQU8sQ0FBRSxJQUFJLENBQUMsVUFBVSxDQUFFLENBQUM7O1lBQ3JFLFdBQVcsQ0FBQyxRQUFRLEdBQUcsSUFBSSxDQUFDO1FBRWpDLHVCQUF1QjtRQUN2QixJQUFJLENBQUMsVUFBVSxHQUFHLEVBQUUsQ0FBQztRQUNyQixJQUFJLENBQUMsSUFBSSxHQUFHLEVBQUUsQ0FBQztJQUNuQixDQUFDO0lBRUQsd0hBQXdIO0lBQ3hILEtBQUs7UUFDRCw4RUFBOEU7UUFDOUUsSUFBSSxDQUFD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","assetPath":"Assets/MainProject/_Scripts/Managers/GameManager.ts","manifest":{"properties":[{"assembly":"mscorlib","name":"pairAmount","type":"System.Single","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"Header","args":["\"Amount
    of pairs (min 2 / max 16)\""]},{"name":"SerializeField","args":[]}]},{"assembly":"UnityEngine.CoreModule","name":"tableParent","type":"UnityEngine.Transform","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"Header","args":["\"References\""]},{"name":"SerializeField","args":[]}]},{"assembly":"UnityEngine.CoreModule","name":"rowPrefab","type":"UnityEngine.GameObject","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"SerializeField","args":[]}]},{"assembly":"UnityEngine.CoreModule","name":"cardPrefab","type":"UnityEngine.GameObject","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"SerializeField","args":[]}]},{"assembly":"mscorlib","name":"useThumbnails","type":"System.Boolean","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"Header","args":["\"Card
    images\""]},{"name":"SerializeField","args":[]}]},{"assembly":"UnityEngine.CoreModule","name":"sprites","type":"UnityEngine.Sprite[]","isArray":true,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[{"name":"SerializeField","args":[]}]},{"assembly":"mscorlib","name":"tries","type":"System.Single","isArray":false,"initValue":[],"enumKeys":[],"enumValues":[],"attributes":[]}],"name":"GameManager","description":"","hasAnimatorMove":false},"isCompiled":true}'
  typescriptHash: eb643f87338b7b76592a0342133e74c3
  onlyWriteTrigger: 0
